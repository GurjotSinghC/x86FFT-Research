	.data
aandb:	.asciiz	"This is a and b"
thisk:	.asciiz	"This is k "
	.align	8


# complex: 	.struct
# real:		.double	0.0
# imaginary:	.double	0.0
# 
# # powerofTwo:	.double	2 cant remember what this is for
# 	.code
# complex.add:
# # complex:v0 complex::add(complex*arg1:a0,complex*arg2:a1)
# 
# 	addi	$sp,$sp,fp.s4-fp.a4	# standard stack frame
# 	sw	$fp,fp.fp-fp.s4($sp)
# 	add	$fp,$sp,fp.fp-fp.s4
# 	sw	$ra,fp.ra($fp)
# 	sw	$s0,fp.s0($fp)
# 	sw	$s1,fp.s1($fp)
# 	sw	$s2,fp.s2($fp)
# 	sw	$s3,fp.s3($fp)
# 	sw	$s4,fp.s4($fp)
# 	sw	$a0,fp.a0($fp)
# 	sw	$a1,fp.a1($fp)
# 	sw	$a2,fp.a2($fp)
# 	sw	$a3,fp.a3($fp)
# 	l.d	$f12,complex.real($a0)
# 	l.d	$f14,complex.imaginary($a0)
# 	l.d	$f16,complex.real($a1)
# 	l.d	$f18,complex.imaginary($a1)
# 	add.d	$f0,$f12,$f16
# 	add.d	$f2,$f14,$f18
# 	s.d	$f0,complex.real($v0)
# 	s.d	$f2,complex.imaginary($v0)
# 
# 	li	$a0,'\n
# 	syscall	$print_char
# 
# 
# 	
# 98:	lw	$ra,fp.ra($fp)	# restore registers from stack
# 	lw	$s0,fp.s0($fp)
# 	lw	$s1,fp.s1($fp)
# 	lw	$s2,fp.s2($fp)
# 	lw	$s3,fp.s3($fp)
# 	lw	$s4,fp.s4($fp)
# 	lw	$fp,fp.fp($fp)
# 	add	$sp,$sp,fp.a4-fp.s4
# 	jr	$ra
# 
# 
# complex.mul:
# #complex:v0 complex::mul(complex * arg1:$a0,complex*arg2:a1)
# 	addi	$sp,$sp,fp.s4-fp.a4	# standard stack frame
# 	sw	$fp,fp.fp-fp.s4($sp)
# 	add	$fp,$sp,fp.fp-fp.s4
# 	sw	$ra,fp.ra($fp)
# 	sw	$s0,fp.s0($fp)
# 	sw	$s1,fp.s1($fp)
# 	sw	$s2,fp.s2($fp)
# 	sw	$s3,fp.s3($fp)
# 	sw	$s4,fp.s4($fp)
# 	sw	$a0,fp.a0($fp)
# 	sw	$a1,fp.a1($fp)
# 	sw	$a2,fp.a2($fp)
# 	sw	$a3,fp.a3($fp)
# 
# 
# 	l.d	$f12,complex.real($a0)
# 	l.d	$f14,complex.imaginary($a0)
# 	l.d	$f16,complex.real($a1)
# 	l.d	$f18,complex.imaginary($a1)
# 
# 	#imaginary times imagery 
# 	mul.d	$f0,$f12,$f16 			#real and real
# 	mul.d	$f2,$f14,$f18 		       	#imagine and maignary
# 	sub.d	$f0,$f0,$f2 			#i*i is -1
# 	
# 	mul.d	$f2,$f14,$f16
# 	mul.d	$f4,$f12,$f18
# 	add.d	$f2,$f2,$f4
# 
# 	s.d	$f0,complex.real($v0)
# 
# 	s.d	$f2,complex.imaginary($v0)
# 98:	lw	$ra,fp.ra($fp)	# restore registers from stack
# 	lw	$s0,fp.s0($fp)
# 	lw	$s1,fp.s1($fp)
# 	lw	$s2,fp.s2($fp)
# 	lw	$s3,fp.s3($fp)
# 	lw	$s4,fp.s4($fp)
# 	lw	$fp,fp.fp($fp)
# 	add	$sp,$sp,fp.a4-fp.s4
# 	jr	$ra
# 
# 
# complex.sub:
# # complex:v0 complex::sub(complex*arg1:a0,complex*arg2:a1)
# 
# 	addi	$sp,$sp,fp.s4-fp.a4	# standard stack frame
# 	sw	$fp,fp.fp-fp.s4($sp)
# 	add	$fp,$sp,fp.fp-fp.s4
# 	sw	$ra,fp.ra($fp)
# 	sw	$s0,fp.s0($fp)
# 	sw	$s1,fp.s1($fp)
# 	sw	$s2,fp.s2($fp)
# 	sw	$s3,fp.s3($fp)
# 	sw	$s4,fp.s4($fp)
# 	sw	$a0,fp.a0($fp)
# 	sw	$a1,fp.a1($fp)
# 	sw	$a2,fp.a2($fp)
# 	sw	$a3,fp.a3($fp)
# 	l.d	$f12,complex.real($a0)
# 	l.d	$f14,complex.imaginary($a0)
# 
# 	l.d	$f16,complex.real($a1)
# 	l.d	$f18,complex.imaginary($a1)
# 	sub.d	$f0,$f12,$f16
# 	sub.d	$f2,$f14,$f18
# 	s.d	$f0,complex.real($v0)
# 	s.d	$f2,complex.imaginary($v0)
# 98:	lw	$ra,fp.ra($fp)	# restore registers from stack
# 	lw	$s0,fp.s0($fp)
# 	lw	$s1,fp.s1($fp)
# 	lw	$s2,fp.s2($fp)
# 	lw	$s3,fp.s3($fp)
# 	lw	$s4,fp.s4($fp)
# 	lw	$fp,fp.fp($fp)
# 	add	$sp,$sp,fp.a4-fp.s4
# 	jr	$ra
# 
# complex.div:
# #complex:v0 complex::div(complex*arg1:a0,complex*arg2:a1)
# 	addi	$sp,$sp,fp.s4-fp.a4	# standard stack frame
# 	sw	$fp,fp.fp-fp.s4($sp)
# 	add	$fp,$sp,fp.fp-fp.s4
# 	sw	$ra,fp.ra($fp)
# 	sw	$s0,fp.s0($fp)
# 	sw	$s1,fp.s1($fp)
# 	sw	$s2,fp.s2($fp)
# 	sw	$s3,fp.s3($fp)
# 	sw	$s4,fp.s4($fp)
# 	sw	$a0,fp.a0($fp)
# 	sw	$a1,fp.a1($fp)
# 	sw	$a2,fp.a2($fp)
# 	sw	$a3,fp.a3($fp)
# 	l.d	$f12,complex.real($a0)
# 	l.d	$f14,complex.imaginary($a0)
# 	l.d	$f16,complex.real($a1)
# 	l.d	$f18,complex.imaginary($a1)
# 	mul.d	$f0,$f12,$f16 	# a*c
# 	mul.d	$f2,$f14,$f18 	# b*d
# 	add.d	$f0,$f0,$f2 	# ac + bd
# 	mul.d	$f2,$f14,$f16	# bc
# 	mul.d	$f4,$f12,$f18	# ad
# 	sub.d	$f2,$f2,$f4	# bc-ad
# 	mul.d	$f4,$f16,$f16	#c²
# 	mul.d	$f8,$f18,$f18	#d²
# 	add.d	$f4,$f4,$f8	#c²+d²
# 	div.d	$f0,$f0,$f4	# whole real term
# 	div.d	$f2,$f2,$f4	# whole imaginary term
# 	s.d	$f0,complex.real($v0)
# 	s.d	$f2,complex.imaginary($v0)
# 98:	lw	$ra,fp.ra($fp)	# restore registers from stack
# 	lw	$s0,fp.s0($fp)
# 	lw	$s1,fp.s1($fp)
# 	lw	$s2,fp.s2($fp)
# 	lw	$s3,fp.s3($fp)
# 	lw	$s4,fp.s4($fp)
# 	lw	$fp,fp.fp($fp)
# 	add	$sp,$sp,fp.a4-fp.s4
# 	jr	$ra




	.data
decimationtable:	.word	0xaaaaaaaa
			.word	0x55555555
			.word	0xcccccccc
			.word	0x33333333
			.word	0xf0f0f0f0
			.word	0x0f0f0f0f
			.word	0xff00ff00
			.word	0xff00ff00
			.word	0x00ff00ff

PHI:	.double	1.0,0.0			# 360  	N=0
	.double	-1.0,0.0		# -180 	N=1
	.double	0.0,-1.0		# -90 	N=2
	.double	0.7071067811865476,-0.7071067811865475 	#-45 	N=3
	.double	0.9238795325112867,-0.3826834323650898	#-22.5 	N=4
	.double	0.9807852804032304,-0.19509032201612825 #-11.25 
	.double	0.9951847266721969,-0.0980171403295606
	.double	0.9987954562051724,-0.04906767432741801
	.double	0.9996988186962042,-0.02454122852291229
	.double	0.9999247018391445,-0.01227153828571993
	.double	0.9999811752826011,-6.135884649154475e-3
	.double	0.9999952938095762,-3.067956762965976e-3
	.double	0.9999988234517019,-1.5339801862847655e-3
	.double	0.9999997058628822,-7.669903187427044e-4
	.double	0.9999999264657179,-3.8349518757139553e-4
	.double	0.9999999816164293,-1.9174759731070328e-4
	.double	0.9999999954041073,-9.587379909597734e-5
	.double 0.9999999988510269,-4.793689960306688e-5
	.double	0.9999999997127567,-2.3968449808418217e-5
	.double	0.9999999999281892,-1.1984224905069705e-5
	.double	0.9999999999820472,-5.992112452642428e-6








	.code

sixteen	=	$s1
#s7 is the this pointer
complex.Cooley_Tukey_FFT:	

		addi	$sp,$sp,fp.s4-fp.a4	# standard stack frame
		sw	$fp,fp.fp-fp.s4($sp)
		add	$fp,$sp,fp.fp-fp.s4
		sw	$ra,fp.ra($fp)
		sw	$s0,fp.s0($fp)
		sw	$s1,fp.s1($fp)
		sw	$s2,fp.s2($fp)
		sw	$s3,fp.s3($fp)
		sw	$s4,fp.s4($fp)
		sw	$a0,fp.a0($fp)
		sw	$a1,fp.a1($fp)
		sw	$a2,fp.a2($fp)
		sw	$a3,fp.a3($fp)				# void fft(CArray &x,unsigned int m)
					# {
					#     // DFT
	#     unsigned int N = x.size(), k = N, n;
		lw	$t0,N		# N = size
		mov	$t1,$t0		# k = N
		li	$t2,0		#n = 0	
					# double thetaT = PI / N; // division done in Long double output into double
	 	l.d	$f0,PI
	 	l.d	$f2,Nfloat	
	 	div.d	$f4,$f0,$f2
	 	s.d	$f4,ThetaT
	 				#Complex phiT = Complex(cos(thetaT), -sin(thetaT)), T;	
	 	#f4 has thetaT	
	 	cos.d	$f6,$f4
	 	sin.d	$f8,$f4
	 	neg.d	$f8,$f8
	 	s.d	$f6,phiT
	 	la	$t9,phiT
	 	s.d	$f8,8($t9)	#basically storing to the double next phiT in memory
	
	
	
		lw	$t8,m
			
		
	
	
		li	$a0,'\n
		syscall	$print_char
		li	$a0,'\n
		syscall	$print_char
		la	$a0,firstphit
		syscall	$print_string	
		l.d	$f12,phiT
		syscall	$print_double
		l.d	$f12,8($t9)
		syscall	$print_double
		#t9 is now phiT address




				#     while (k > 1)
				#     {
		li	$t6,1
top:		bgt	$t6,$t1,whileend
			#      n = k;
		mov	$t2,$t1
				#      k >>= 1;
		srl	$t1,$t1,1
				#      phiT = phiT * phiT;
		la	$v0,phiT  		#output stored here
		la	$a0,phiT
		la	$a1,phiT
	
	
		jal	complex.mul
	
		li		$a0,'\n	#this is the debug string to view the first phit calc
		syscall		$print_char
		la		$a0,firstph2
		syscall		$print_string
	
		l.d		$f12,phiT	#prints real value of phit
		syscall		$print_double
	
	
		la		$a0,SPACE
		syscall		$print_string
	
	
		la		$a0,phiT	#prints the imaginary v alue of phit
		l.d		$f12,8($a0)
		syscall		$print_double
	
		li		$a3,1
		mtc1		$a3,$f0
		cvt.d.w		$f0,$f0
		la		$a3,T
		s.d		$f0,complex.real($a3)
		
		mtc1		$0,$f0
		mtc1		$0,$f1
		cvt.d.w		$f0,$f0
		s.d		$f0,complex.imaginary($a3)
	
		li		$t9,0 #l =0				
tloop:				#         for (unsigned int l = 0; l < k; l++)
	
		bge		$t9,$t1,tloopend	
				#         {floop
				#             for (unsigned int a = l; a < N; a += n)
		mov		$t8,$t9	#a = l
sloop:	bge		$t8,$t0,sloopend
					#             
					# 	unsigned int b = a + k;
	add			$t3,$t8,$t1	# Complex t = x[a] - x[b];
	la			$t7,Data 		#array

	la			$a0,aandb
	syscall			$print_string

	mov			$a0,$t8
	syscall			$print_int

	la			$a0,SPACE
	syscall			$print_string

	mov			$a0,$t3
	syscall			$print_int
	
	li			$s1,16
	mul			$a0,$t8,$s1

	add			$a0,$t7,$a0 #x[a]	

	mul			$s0,$t3,$s1	# multily b by 16
	


	
	add			$a1,$t7,$s0

	la			$v0,t	#need to know the address of the output	
	jal			complex.sub #cahnged from mul	



	li			$a0,'\n		#this is t printing
	syscall			$print_char
	la			$a0,compsub
	syscall			$print_string
	l.d			$f12,t
	syscall			$print_double
	la			$a0,SPACE
	syscall			$print_string
	la			$t0,t
	l.d			$f12,8($t0)
	syscall			$print_double

	
			#                 x[a] += x[b];
	mov			$s0,$t8	#t8 is a
	li			$s1,16
	mul			$s0,$s0,$s1 #byte index a
	add			$a0,$t7,$s0 #x[a]
	mov			$v0,$a0	#fixes
	mov			$s0,$t3	#b
	mul			$s0,$s0,$s1	# multily b by 16
	add			$a1,$t7,$s0

	jal			complex.add
	

# 	li	$a0,'\n
# 	syscall	$print_char
	
	la			$a0,compadd
	syscall		$print_string
# 
	l.d			$f12,complex.real($v0)
 	syscall		$print_double

	la			$a0,SPACE
	syscall		$print_string
	l.d			$f12,complex.imaginary($v0)
	syscall		$print_double


			#                 x[b] = t * T;
	mov			$s0,$t3	#b
	mul			$s0,$s0,$s1	# multily b by 16
	add			$v0,$s0,$t7

	la			$a0,t
	la			$a1,T
	jal			complex.mul

	li			$a0,'\n
	syscall		$print_char
	la			$a0,tandt
	syscall		$print_string


	l.d			$f12,($v0)
	syscall		$print_double
	la			$a0,SPACE
	syscall		$print_string
	l.d			$f12,8($v0)
	syscall		$print_double
	li			$a0,'\n
	syscall		$print_char
	add			$t8,$t8,$t2 #a+=n
	j			sloop
sloopend:	#             }sloop
						#             T *= phiT;
	la			$a0,T
	la			$a1,phiT
	la			$v0,T

	jal			complex.mul

	addi			$t9,1
	la			$a0,TtT
	syscall		$print_string
	
	l.d			$f12,complex.real($v0)
	syscall		$print_double

	la			$a0,SPACE
	syscall		$print_string

	l.d			$f12,complex.imaginary($v0)
	syscall		$print_double	

	j			tloop			#         }floop

tloopend:
	j			top

#end of while lop
	jal			printalldata
				#     }while
whileend:
	la			$s6,decimationtable

				#     // Decimate
				#     //    unsigned int m = (unsigned int)log2(N);
			#     
	li			$t8,0 #a=0				#{
	lw			$s7,N
	li			$a0,'V
	syscall		$print_char
	l.d			$f12,phiT
	syscall		$print_double
Decimate:
bga:
	la			$s6,decimationtable
	bge			$t8,$s7,FinishDecimate	#     for (unsigned int a = 0; a < N; a++)
				#         unsigned int b = a;
	mov			$t3,$t8
				#         // Reverse bits
				#         b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));
	lw			$s3,0($s6)

	and			$t9,$t3,$s3
	srl			$t9,$t9,1

	lw			$s3,4($s6)
	and			$s2,$t3,$s3
	sll			$s2,$s2,1
	or			$t3,$t9,$s2
				#         b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));
	lw			$s3,8($s6)
	and			$t9,$t3,$s3
	srl			$t9,$t9,2
	lw			$s3,12($s6)

	and			$s2,$t3,$s3
	sll			$s2,$s2,2
	or			$t3,$t9,$s2
				#         b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));

	lw			$s3,16($s6)
	and			$t9,$t3,$s3
	srl			$t9,$t9,4
	lw			$s3,20($s6)
	and			$s2,$t3,$s3
	sll			$s2,$s2,4
	or			$t3,$t9,$s2
				#         b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));
	lw			$s3,24($s6)
	and			$t9,$t3,$s3
	srl			$t9,$t9,8
	lw			$s3,28($s6)
	and			$s2,$t3,$s3
	sll			$s2,$s2,8
	or			$t3,$t9,$s2
				#         b = ((b >> 16) | (b << 16)) >> (32 - m);
	srl			$t9,$t3,16
	sll			$s0,$t3,16
	
	or			$t9,$t9,$s0

	lw			$v1,m
	neg			$v1,$v1
	addi			$s1,$v1,32
	srl			$t3,$t9,$s1
	addi			$t8,1
# bga:				#         if (b > a)
				#         {
	blt			$t8,$t3,2f
1:				#             //            Complex t = x[a];
	li			$s7,16
	mul			$s4,$s7,$t8
	add			$s4,$t7,$s4
	l.d			$f0,($s4)
	s.d			$f0,t
	l.d			$f2,t
			#             //            x[a] = x[b];
	li			$s7,16
	mul			$s7,$s7,$t3
	add			$s5,$t7,$s7	#s5 is x[b]
	l.d			$f0,($s5)
	s.d			$f0,($s4)	

	mov.d			$f12,$f0
	syscall		$print_double				#             //            x[b] = t;
	l.d			$f0,t
	s.d			$f0,($s5)	
	jal			printalldata


				#         }
2:
	j			Decimate	
FinishDecimate:	
		#     }
			

97:	

	la			$t7,Data
	
	l.d			$f0,complex.real($t7)
	l.d			$f2,complex.imaginary($t7)
	l.d			$f4,16($t7)
	l.d			$f6,24($t7)

	s.d			$f4,($t7)
	s.d			$f6,8($t7)
	
	s.d			$f0,16($t7)
	s.d			$f2,24($t7)


	l.d			$f14,Rounding_Factor	#LOAD THE ROUDNIGN FACTOR


	li			$t0,32
	li			$t1,0
	la			$t2,Data
	addi			$t2,-8
	l.d			$f2,NormalizationRange
	li			$s1,0
	mtc1			$s1,$f0
	cvt.d.w			$f0,$f0
	li			$t1,8
Normalize:	
	bltz			$t0,END   
	
	add			$t2,$t2,$t1
	
	l.d			$f12,($t2)
	abs.d			$f12,$f12
	addi			$t0,-1


	mul.d			$f12,$f14,$f12
	round.d		$f12,$f12
	floor.d		$f12,$f12	
	div.d			$f12,$f12,$f14
	s.d			$f12,($t2)

	c.le.d		$f12,$f2

	bc1t			zeroutvalue
		
	j			Normalize
	
zeroutvalue:


	s.d			$f0,($t2)
	l.d			$f12,($t2)
	syscall		$print_double

	j			Normalize






END:
	  jal			printalldata


98:	

	lw	$ra,fp.ra($fp)	# restore registers from stack
	lw	$s0,fp.s0($fp)
	lw	$s1,fp.s1($fp)
	lw	$s2,fp.s2($fp)
	lw	$s3,fp.s3($fp)
	lw	$s4,fp.s4($fp)
	lw	$fp,fp.fp($fp)
	add	$sp,$sp,fp.a4-fp.s4
	jr	$ra